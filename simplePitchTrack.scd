(

GUI.qt;          // Platform independent GUI system
MIDIClient.init; // initialize the MIDIClient on Server
m = MIDIOut(0);  // use first MIDI Device (IAC BUS 1)

~onOrOff     = false;
~pitch       = 0;
~changePitch = 0;
~lastPitch   = 0;
~resolution  = 7;
~currentRes  = 0;
~currentDir  = thisProcess.nowExecutingPath.dirname; // seemingly platform independent (Check TODO)
~gooeyBounds = [500, 500, 500, 500];                 // x pos, y pos, width, height

/* * * * * * * * * * * *
  * - - - - - - - - - - *
 * -       GUI         - *
 * -       CODE        - *
  *  - - - - - - - - -  *
 * * * * * * * * * * * *
 * TODO: create GUI Scope (that isn't global, TODO)
*/

~gooey         = Window.new("Pitch Tracker", Rect(500,500,500,500));
~devicesBtn    = Button(~gooey, Rect(125, 20,  120, 30)).states_([["Device"], ["Device Options"]]);
~configBtn     = Button(~gooey, Rect(250, 20,  120, 30)).states_([["Config"], ["Configuration Options"]]);
~loadConfigBtn = Button(~gooey, Rect(125, 450, 120, 30)).states_([["Load Config File"]]);

~devicesBtn.action = {
	arg view, char; // switch to Device view (TODO)

	~devicesBtn.value = 1;
	~configBtn.value  = 0;
};

~configBtn.action = {
	arg view, char; // switch to Config view (TODO)

	~configBtn.value  = 1;
	~devicesBtn.value = 0;
};

~loadConfigBtn.action = {
	arg view, char, f;

	f = File(~currentDir +/+ "configure.txt", "w");
	f.readAllString;
	// if file exists, parse and load globals
	// if not, create file with defaults

	f.close; // safely remove device :P
};

~gooey.front;

SynthDef(\freqTrack, {
	arg threshold = (0.93), median = (63), framesize = (512), overlap = (256), delayTime = (0.10);
	var freq, in, tart, changeFreq;

	/*

	  FreqTrack: Pipe in to Pitch
	  calculates the MIDI number of the input sound
	  median: remove outliers, 11 in this case takes the median of last 11 frames,
	  framesize:
	  overlap:
	  delayTime:

	*/

	in         = SoundIn.ar(0);
	tart       = Tartini.kr(in, threshold, framesize, 0, overlap);
	freq       = Median.kr(median, tart).cpsmidi.round;
	changeFreq = DelayN.kr(Median.kr(67, tart).cpsmidi.round, delaytime: delayTime);

	SendReply.ar(Impulse.ar(50), 'pitch', [freq]);
	SendReply.ar(Impulse.ar(50), 'changePitch', [changeFreq]);
}).play;

SynthDef(\threshTest, {
	arg highThresh = (-22), lowThresh = (-40), delayTime = (0.10);
	var amp, highTrig, lowTrig, in, sig;

	in  = SoundIn.ar(0);
	sig = DelayN.ar(in, delaytime: delayTime);
	amp = Amplitude.kr(sig).ampdb; // return Amplitude to to Decibals
	amp = K2A.ar(amp);             // to improve resolution of amplitude tracking control -> audio rate

	highTrig = amp >= highThresh;
	lowTrig  = amp <= lowThresh;

	SendReply.ar(Impulse.ar(50), 'highTrigVal', [highTrig]); // Respective triggers for noteOn
	SendReply.ar(Impulse.ar(50), 'lowTrigVal', [lowTrig]);   // and noteOff
}).play;

/*

  OSC Responder (event emitters) for OSC messages
  serve the purpose of dispatching anonymous functions

*/

~oscr4.remove;
~oscr4 = OSCresponder(nil, 'pitch', {
	|time, resp, msg|

	~currentRes = ~currentRes -1;
	if(not(msg[3] == ~pitch), {
		~pitch = msg[3]; // save pitch to global variable ~pitch
	});

}).add;

~oscr3.remove;
~oscr3 = OSCresponder(nil, 'changePitch', {
	|time, resp, msg|

	~changePitch = msg[3];
	if ((~currentRes <= 0) && ~onOrOff && not(~lastPitch == ~changePitch) &&
		not(~lastPitch == ~pitch) && (~pitch == ~changePitch), {
			"note on slur, pitch ".post;
			~pitch.postln;
			~lastPitch.postln;
			m.noteOff(16, ~lastPitch, 0);
			m.noteOn(16, ~pitch, 60);
			~lastPitch = ~pitch;
			~currentRes = ~resolution;
	});

}).add;

~oscr1.remove;
~oscr1 = OSCresponder(nil, 'highTrigVal', {
	|time, resp, msg|

	if((msg[3] == 1) && not(~onOrOff) && (~currentRes <= 0), {
		"note on, pitch ".post;
		~pitch.postln;
		m.noteOff(16, ~lastPitch, 0);
		m.noteOn(16, ~pitch, 60);
		~lastPitch = ~pitch;
		~onOrOff = true;
		~currentRes = ~resolution;
	});

}).add;

~oscr2.remove;
~oscr2 = OSCresponder(nil, 'lowTrigVal', {
	|time, resp, msg|

	if((msg[3] == 1) && (~onOrOff) , {
		"note off".postln;
		m.noteOff(16, ~lastPitch, 0);
		~onOrOff = false;
	});
}).add;

)